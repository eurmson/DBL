#![allow(unused)]
use crate::algorithm_hiding::{self, create_unique_id, UniqueId};
use crate::file_management;
use crate::file_management::{Files, Directory};
use crate::file_system_hiding::file_log;
use file_log::FileLog;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::hash::Hash;
use std::path::{Path, PathBuf};
use serde_json::{json, Value, Error};
use std::rc::Rc;
use std::cell::{Ref, RefCell};

const DEFAULT_BRANCH_NAME:&str = "main";


type NodePointer = Option<Rc<RefCell<RGNode>>>;

trait Serializable{
    fn serialize(& mut self, file_name: PathBuf) -> std::result::Result<(), Error>;
}
#[derive(Debug, Serialize, Deserialize, Clone)]
struct RGData{
    // A list of file names tracked for given revision. Addition/removal of files from tracking list affects this
    track_list: Vec<PathBuf>,
    // Added a hashmap to track IDs associated with files of a given revision (ID generated by file_log module)
    commit_map: HashMap<PathBuf, UniqueId>,
}

impl RGData{
    fn new(file_names: Vec<PathBuf>, commit_map: HashMap<PathBuf, UniqueId>) -> Self{
        RGData{
            track_list: file_names,
            commit_map: commit_map,
        }
    }
    fn add_files(&mut self, file_names: Vec<PathBuf>){
        
        file_names.iter().for_each(|fname| {
            if !self.track_list.contains(fname){
                self.track_list.push(fname.clone());
            }
        });
    }
    fn remove_files(& mut self, file_names: Vec<PathBuf>){
        let temp_list: Vec<&PathBuf> = self.track_list.iter().filter(|&fname_1| !file_names.contains(fname_1)).collect();
        self.track_list = temp_list.iter().map(|&fname| fname.clone()).collect();
    }
    fn add_merge_commits(&mut self, merge_map: HashMap<PathBuf, String>){
        let mut fl = file_log::create_file_log::<Directory>();
        self.track_list.iter().for_each(|fname| {
            let res = fl.save_file_merge(fname, &merge_map.get(fname).unwrap());
            match res{
                Ok(id) => {
                    self.commit_map.insert(fname.clone(), id);
                }
                Err(e) => {
                    // Handle this
                }
            }
        })
    }
    fn add_commits(&mut self){
        // println!("Called");
        // println!("track list: {:?}", self.track_list);
        self.track_list.iter().for_each(|fname| {
            let mut fl = file_log::create_file_log::<Directory>();
            let res = fl.save_file(fname.clone().as_path());
            // println!("conv unique id: {:?}", res);
            match res{
                Ok(id) => {
                    // println!("conv unique id: {:?}", id);
                    self.commit_map.insert(fname.clone(), id);
                }
                Err(e) => {
                    // println!("The file was not converted to uniqueID");
                }
            }
        });
    }
}

// TODO: Think about whether data should be an Option or when data needs to be empty you should just have an empty vector?
#[derive(Debug)]
struct RGNode{
    data: RGData,
    id: Option<UniqueId>,
    p1: NodePointer,
    p2: NodePointer,
}

struct RevGraph<T> where T: Files{
    // Hashmap to keep track of revision and files associated with each
    graph: HashMap<UniqueId, NodePointer>,
    // Hashmap to keep track of nodes at the head of each branch
    heads: HashMap<String, NodePointer>,
    // Pointer to the current node of the current branch
    curr_rev: NodePointer,
    _t: Option<T>,
}

impl<T> RevGraph<T> where T: Files{
    fn init() -> Self{
        let rev = RevGraph{
            graph: HashMap::new(),
            heads: HashMap::new(),
            curr_rev: None,
            _t: None,
        };
        rev
    }
    // TODO: update to reinitialize rev graph from info stored in hidden dir
    fn reinit(& mut self, rg_str: String) -> std::result::Result<(), Error>{
        let v: (Vec<(UniqueId, RGData)>, Vec<(Option<UniqueId>, Option<UniqueId>)>, HashMap<String, (RGData, Option<UniqueId>, Option<UniqueId>)>) = serde_json::from_str(&rg_str)?;
        // println!("\n\n\nv: {v:?}\n\n\n");
        self.reconstruct_rev_graph(v);
        Ok(())
    }

    // TODO: This function should return result
    fn add_files(& mut self, file_names: Vec<PathBuf>){
        // println!("AAAAAAAAAAAA:{:?}", self.curr_rev);
        match &self.curr_rev{
            Some(rg_node) => {
                // println!("curr_rev already initialized!!");

                // TODO: Handle the case of trying to add files that are already being tracked (error or just a message?)
                (*rg_node).borrow_mut().data.add_files(file_names);
            }
            _ => {                
                // println!("curr_rev NOT initialized!!");
                let mut rg_node = Rc::new(RefCell::new(RGNode{
                    data: RGData::new(file_names, HashMap::new()),
                    id: None,
                    p1: None,
                    p2: None,
                }));
                self.curr_rev = Some(rg_node);
                self.point_head(DEFAULT_BRANCH_NAME.to_string());
            }
        }
    }

    // TODO: This function should return result
    fn remove_files(& mut self, file_names: Vec<PathBuf>){
        match &self.curr_rev{
            Some(rg_node) =>{
                // TODO: Add the error case of when RGNode is initialized but no files are being tracked
                (*rg_node).borrow_mut().data.remove_files(file_names);
            }
            // TODO: Handle the Error case of trying to remove files when RGNode is either uninitialized
            _ => {

            }
        }
    }

    fn add_merge_node(&mut self, merge_map: HashMap<PathBuf, String>, rev_id_1: UniqueId, rev_id_2: UniqueId){
        match &self.curr_rev{
            Some(rg_node) => {
                let mut fl = file_log::create_file_log::<Directory>();
                let id = create_unique_id();
                let mut file_names: Vec<PathBuf> = Vec::new();
                merge_map.iter().for_each(|(k, v)| file_names.push(k.clone()));
                let mut new_node = Rc::new(RefCell::new(RGNode{
                    data: RGData::new(file_names.clone(), HashMap::new()),
                    id: Some(id.clone()),
                    p1: Some(Rc::clone(&self.graph.get(&rev_id_1).unwrap().as_ref().unwrap())),
                    p2: Some(Rc::clone(&self.graph.get(&rev_id_2).unwrap().as_ref().unwrap())),
                }));
                new_node.borrow_mut().data.add_merge_commits(merge_map.clone());
                self.curr_rev = Some(Rc::new(RefCell::new(RGNode{
                    data: RGData::new(file_names.clone(), HashMap::new()),
                    id: None,
                    p1: Some(Rc::clone(&new_node)),
                    p2: None,
                })));
                self.graph.insert(id.clone(), Some(new_node));
                self.point_head(DEFAULT_BRANCH_NAME.to_string());
                merge_map.iter().for_each(|(k, v)|{T::write_to_file(k, v, false);});
            }
            None => {}
        }
    }
    // TODO: This function should return result
    fn add_graph_node(& mut self) -> Result<UniqueId, String>{
        match &self.curr_rev{
            // TODO: Handle the error case of committing when no files are being tracked
            Some(rg_node) =>{
                // println!("{:?}", rg_node);
                let mut fl = file_log::create_file_log::<Directory>();
                let id = create_unique_id();
                {
                let mut node_ref = (*rg_node).borrow_mut();
                node_ref.data.add_commits();
                node_ref.id = Some(id.clone());
                }
                // Create a new node tracking same files as current revision
                // Set one of the parents to the current revision and stash away the curr rev
                // Set curr rev to the new node
                let new_node = Rc::new(RefCell::new(RGNode{
                    data: RGData::new(rg_node.borrow().data.track_list.clone(), HashMap::new()),
                    id: None,
                    p1: Some(Rc::clone(rg_node)),
                    p2: None,
                }));
                // println!("{:?}", id);
                self.graph.insert(id.clone(), Some(Rc::clone(rg_node)));
                self.curr_rev = Some(new_node);
                self.point_head(DEFAULT_BRANCH_NAME.to_string());
                Ok(id)
            }
            _ => {
                Err("No Files Currently Being Tracked".to_string())
                // TODO: Handle the error case of committing before the node even exists
            }
        }
    }
    // adds a new head to the heads hashmap in rev_graph
    fn point_head(& mut self, branch_name: String) {
        match &self.curr_rev{
            Some(rg_node) =>{
                self.heads.insert(branch_name.clone(), Some(Rc::clone(rg_node)));
                // println!("IDK WHAT THIS IS TESTING{:?}", self.heads.get(&branch_name))
            }
            // TODO: Handle the Error case of trying to point head to curr_rev when curr_rev is uninitialized
            // Realistically, this case should not even arise
            _ => {

            }
        }
    }

    fn checkout_commit(&mut self, track_list: Vec<PathBuf>, commit_map: HashMap<PathBuf, UniqueId>){
        let mut fl = file_log::create_file_log::<Directory>();
        match &self.curr_rev{
            Some(rg_node) => {
                // let rev_node = self.graph.get(&rev_id).unwrap().as_ref().unwrap();
                let par_1 = rg_node.borrow_mut().p1.clone();
                let par_2 = rg_node.borrow_mut().p2.clone();
                self.curr_rev = Some(Rc::new(RefCell::new(RGNode{
                    data: RGData::new(track_list, HashMap::new()),
                    id: None,
                    p1: par_1, 
                    p2:par_2,
                })));
                self.point_head(DEFAULT_BRANCH_NAME.to_string());
                commit_map.iter().for_each(|(k, v)|{
                    let opt = fl.retrieve_version(k, v.clone());
                    match opt {
                        Some(file_content) => {
                            T::write_to_file(k, &file_content, false);
                        }
                        None => {}
                    };
                });
            }
            None => {}
        }
    }

    fn vectorize_rev_graph(&self) -> (Vec<(UniqueId, RGData)>, Vec<(Option<UniqueId>, Option<UniqueId>)>, HashMap<String, (RGData, Option<UniqueId>, Option<UniqueId>)>){
        let mut vec_rg_nodes: Vec<(UniqueId, RGData)> = Vec::new();
        let mut vec_parents_info: Vec<(Option<UniqueId>, Option<UniqueId>)> = Vec::new();
        self.graph.iter()
            .for_each(|(&k,v)|
                            if let Some(node) = v {
                                // println!("{:?}", node);
                                vec_rg_nodes.push((k, (*node).borrow_mut().data.clone()));
                                let rgn = (*node).borrow_mut();
                                let p1 = rgn.p1.clone();
                                let p2 = rgn.p2.clone();
                                match (p1, p2){
                                    (Some(n1), None) => { vec_parents_info.push((n1.borrow_mut().id, None));}
                                    (Some(n1), Some(n2)) => { vec_parents_info.push((n1.borrow_mut().id, n2.borrow_mut().id));}
                                    (None, Some(n2)) => {vec_parents_info.push((None, n2.borrow_mut().id));}
                                    (None, None) => {vec_parents_info.push((None, None))}
                                }
                                // vec_parents_info.push((rgn.p1.clone().unwrap().borrow_mut().id, rgn.p2.clone().unwrap().borrow_mut().id))
                            });

        // String is the branch Name, RGData is the data stored in the current node of the given branch, Unique IDs of the parents
        let mut s_heads: HashMap<String, (RGData, Option<UniqueId>, Option<UniqueId>)> = HashMap::new();
        self.heads.iter()
            .for_each(|(k, v)| {
                if let Some(node) = v {
                    let rgn = (*node).borrow_mut();
                    let p1 = rgn.p1.clone();
                    let p2 = rgn.p2.clone();
                    match (p1, p2){
                        (Some(n1), None) => {s_heads.insert(k.clone(), (rgn.data.clone(), n1.borrow_mut().id.clone(), None));}
                        (Some(n1), Some(n2)) => {s_heads.insert(k.clone(), (rgn.data.clone(), n1.borrow_mut().id, n2.borrow_mut().id));}
                        (None, Some(n2)) => {s_heads.insert(k.clone(), (rgn.data.clone(), None, n2.borrow_mut().id));}
                        (None, None) => {s_heads.insert(k.clone(), (rgn.data.clone(), None, None));}
                    }
                    // s_heads.insert(k.clone(), (rgn.data.clone(), p1.unwrap().borrow_mut().id, p2.unwrap().borrow_mut().id));
            // let rgn = v.clone().unwrap().borrow_mut();
            // let res = s_heads.insert(k, (rgn.data.clone(), rgn.p1.unwrap().borrow_mut().id.unwrap(), rgn.p1.unwrap().borrow_mut().id.unwrap()))
        }
    });
        // println!("heads {:?}", s_heads);
        // println!("{:?}", vec_parents_info);
        (vec_rg_nodes, vec_parents_info, s_heads)
    }

    fn reconstruct_rev_graph(& mut self, recon_data: (Vec<(UniqueId, RGData)>, Vec<(Option<UniqueId>, Option<UniqueId>)>, HashMap<String, (RGData, Option<UniqueId>, Option<UniqueId>)>)) {
        self.graph = HashMap::new();
        let vec_rg_nodes = recon_data.0;
        let vec_parents_info = recon_data.1;
        let s_heads = recon_data.2;
        let mut vec_actual_parents: Vec<(NodePointer, NodePointer)> = Vec::new();
        vec_parents_info.iter().for_each(|(p1_id, p2_id)| {
            // println!("pids {:?}", (p1_id, p2_id));
            let mut parents: (NodePointer, NodePointer) = (None, None);
            vec_rg_nodes.iter().for_each(|(id, data)|{
                // println!("id: {:?}", id);
                match Some(id.clone()) {
                    a if a  == *p1_id => {
                        // println!("p1_id {:?}", p1_id);
                        parents.0 = Some(Rc::new(RefCell::new(RGNode{
                            data: RGData::new(data.track_list.clone(), data.commit_map.clone()),
                            id: *p1_id,
                            p1: None,
                            p2: None,
                        })));},
                    a if a == *p2_id => {
                        // println!("p2_id {:?}", p1_id);
                        parents.1 = Some(Rc::new(RefCell::new(RGNode{
                        data: RGData::new(data.track_list.clone(), data.commit_map.clone()),
                        id: *p2_id,
                        p1: None,
                        p2: None,
                    })));},
                    _ => {},
                }
            });
       vec_actual_parents.push(parents)});
    //    println!("parents \n \n: {:?}", vec_actual_parents);
       vec_actual_parents.reverse();
    //    println!("parents[0]: {:?}", vec_actual_parents);

       vec_rg_nodes.iter().for_each(|(id, data)|{
                            let parents = vec_actual_parents.pop().unwrap();
                            self.graph.insert(id.clone(), Some(Rc::new(RefCell::new(RGNode{
                            // data: Some(RGData::new(file_names)),
                            data: RGData::new(data.track_list.clone(), data.commit_map.clone()),
                            id: Some(id.clone()),
                            p1: parents.0,
                            p2: parents.1,
                        })))
                    );
                });

    s_heads.iter().for_each(|(k, v)| {
        let node_data = v.0.clone();
        let p1_id = v.1;
        let p2_id = v.2;

        let mut parents: (NodePointer, NodePointer) = (None, None);
            self.graph.iter().for_each(|(rev, node)|{
                let some_node = node.clone().unwrap();
                // let rgn = some_node.borrow_mut();
                let data = some_node.borrow_mut().data.clone();
                // println!("id: {:?}", id);
                match Some(rev.clone()) {
                    a if a  == p1_id => {
                        // println!("p1_id {:?}", p1_id);
                        parents.0 = Some(Rc::clone(&some_node));},
                    a if a == p2_id => {
                        // println!("p2_id {:?}", p1_id);
                        parents.1 = Some(Rc::clone(&some_node));},
                    _ => {},
                }
            });
            self.heads.insert(k.clone(), Some(Rc::new(RefCell::new(RGNode{
                data: node_data,
                id: None,
                p1: parents.0,
                p2: parents.1,
            }))));

            match self.heads.get(&DEFAULT_BRANCH_NAME.to_string()).unwrap().clone(){
                Some(rg_node) =>{
                    // println!("{:?}", rg_node);
                    self.curr_rev = Some(rg_node);
                }
                // TODO: Handle the Error case of trying to point head to curr_rev when curr_rev is uninitialized
                // Realistically, this case should not even arise
                _ => {
    
                }
            }
    });
    }

    fn traverse_rev_graph(&self, rev_id: UniqueId, mut info_vec: Vec<(String, RGData)>) -> Result<Vec<(String, RGData)>, String>{
        let node = match self.graph.get(&rev_id){
            Some(node) => {
                let dat = node.clone().unwrap().borrow_mut().data.clone();
                let p1 = node.clone().unwrap().borrow_mut().p1.clone();
                let p2 = node.clone().unwrap().borrow_mut().p2.clone();
                info_vec.push((rev_id.into_string(), dat));
                match (p1, p2){
                    (Some(n1), None) => {
                        let id1 = n1.borrow_mut().id.clone().unwrap();
                        info_vec = self.traverse_rev_graph(id1, info_vec.clone()).unwrap_or(info_vec);
                    },
                    (None, Some(n2)) => {
                        let id2 = n2.borrow_mut().id.clone().unwrap();
                        info_vec = self.traverse_rev_graph(id2, info_vec.clone()).unwrap_or(info_vec);
                    },
                    (Some(n1), Some(n2)) => {
                        let id1 = n1.borrow_mut().id.clone().unwrap();
                        info_vec = self.traverse_rev_graph(id1, info_vec.clone()).unwrap_or(info_vec);
                        let id2 = n2.borrow_mut().id.clone().unwrap();
                        info_vec = self.traverse_rev_graph(id2, info_vec.clone()).unwrap_or(info_vec);
                    },
                    _ => {},
                };
                Ok(info_vec)
            },
            _ => {Err("No such revision exists".to_string())}
        };
        node
    }
}

impl<T> Serializable for RevGraph<T> where T: Files{
    fn serialize(& mut self, file_name: PathBuf) -> std::result::Result<(), Error>{
        let mut rg_str = "".to_string();
        if self.graph.is_empty() && self.curr_rev.is_none() && self.heads.is_empty() {
            rg_str = "{}".to_string();
        }
        else{
            let tuple = self.vectorize_rev_graph();
            rg_str = serde_json::to_string(&tuple)?;
        }

        if let Err(e) = T::write_to_file(&file_name, &rg_str, true){
            eprintln!("Failed to create/write to file: {}", e);
        }
        Ok(())
    }
}

pub fn action_handler<T: Files>(command: String, file_names: Option<Vec<PathBuf>>, branch_name: Option<String>, rev_id: Vec<Option<UniqueId>>) -> Result<String, String>{
    let rev_graph_info_file = PathBuf::from("rg_info.json");
    let mut init_res = String::from("initialized");
    let mut rg: RevGraph<T>;
    rg = RevGraph::init();
    // println!("Before:\n{:?}\n, {:?}\n, {:?}\n", rg.graph, rg.heads, rg.curr_rev);
    match T::read_file(&rev_graph_info_file, true) {
        Ok(x) if x != "{}".bytes().collect::<Vec<u8>>() => {
            rg.reinit(String::from_utf8(x).unwrap());}
        _ => {
            rg.serialize(rev_graph_info_file.clone());
        }
    }
    
   
    // if init_data != "{}" {
    //     println!("AAAA");
    //
    // }
    // println!("After:\n{:?}\n, {:?}\n, {:?}\n", rg.graph, rg.heads, rg.curr_rev);
    rg.serialize(rev_graph_info_file.clone());

    let branch_name = branch_name.unwrap_or_else(|| DEFAULT_BRANCH_NAME.to_string());

    
    let mut fl = file_log::create_file_log::<Directory>();
    let res = match command.as_str() {
        "init" => {
            // TODO: Combine init and reinit code (if rg_info has init info then reinit else init afresh)
            // Serialize is called before exiting after completing command
            rg.serialize(rev_graph_info_file.clone());
            Ok(init_res)
        }
        "add" => {
            match file_names {
                Some(file_names) => {
                    // println!("{:?}", file_names);
                    rg.add_files(file_names.clone());
                    // println!("{:?}\n, {:?}\n, {:?}\n", rg.graph, rg.heads, rg.curr_rev);
                    Ok("Added files to repo".to_string())
                }
                None => {
                    Err(String::from("Missing File names to add"))
                }

            }
        }
        "remove" => {
            match file_names {
                Some(file_names) => {
                    rg.remove_files(file_names.clone());
                    Ok("Stopped tracking files".to_string())
                }
                None => {
                    Err(String::from("Missing File names to remove"))
                }
            }
        }
        "commit" => {
            // println!("{:?}", rg.graph);
            // println!("{:?}", rg.curr_rev);
            match rg.add_graph_node(){
                    Ok(id) => {Ok(id.into_string())}
                    Err(msg) => {Err(msg)}
            }
            // println!("{:?}", rg.curr_rev);
            // println!("{:?}", rg.graph);
            // Ok("Commited Files".to_string())
        }
        "status" => {
            let t_list = rg.curr_rev.clone().unwrap().borrow_mut().data.track_list.clone();
            // let res = serde_json::to_string(&t_list);
            let mut msg = "Tracked files: \n".to_string();
            for file in &t_list {
                msg.push_str(" - ");
                msg.push_str(file.as_os_str().to_str().unwrap());
                msg.push_str("\n");
            }
            Ok(msg)
            // match res{
            //     Ok(msg) => {Ok(msg)}
            //     Err(e) => {Err("something went wrong".to_string())}
            // }
            // Ok("".to_string())
            // todo!()
        }
        "cat" => {
            match (rev_id.get(0).take().unwrap_or(&None), file_names) {
                (Some(rev_id), Some(file_names)) => {
                    // println!("{:?}", rg.graph);
                    // println!("{:?}", rev_id);
                    // println!("file: {:?}", file_names[0]);
                    let &file_id = rg.graph.get(&rev_id).unwrap().as_ref().unwrap().borrow_mut().data.commit_map.get(&file_names[0]).unwrap();
                    if let Some(file_content) = fl.retrieve_version(file_names[0].as_path(), file_id) {
                        Ok(file_content)
                    } else {
                        Err("Could not get file version".to_string())
                    }
                }
                (Some(_), None) => Err(String::from("Missing revision ID")),
                (None, Some(_)) => Err(String::from("Missing file name")),
                _ => Err(String::from("Missing file_id and revision_id"))
            }
        }
        "log" => {
            let rev = if rev_id.len() > 0 {
                match rev_id[0] {
                    Some(rev_id) => Ok(rev_id),
                    None => Err(String::from("Missing revision ID"))
                }
            } else {
                if let Some(cur_rev) = rg.curr_rev.clone() {
                    if let Some(a) = cur_rev.borrow().p1.clone() {
                        match a.borrow().id.clone() {
                            Some(rev_id) => Ok(rev_id),
                            None => Err(String::from("Error occurred"))
                        }
                    } else {
                        Err("No Commits".to_string())
                    }
                } else {
                    Err("Repo Not initialized or tracking files".to_string())
                }
            };
            let mut msg = "HEAD -> ".to_string();
            let mut info_vec: Vec<(String, RGData)> = Vec::new();
            let res = match rev {
                Ok(rev) => rg.traverse_rev_graph(rev, info_vec),
                Err(e) => Err(e),
            };

            match res{
                Ok(iv) => {
                    for (i,v) in iv{
                        msg.push_str(&i);
                        msg.push_str(" - ");
                        for file in &v.track_list {
                            msg.push_str(file.as_os_str().to_str().unwrap());
                            msg.push_str(", ");
                        }
                        if !&v.track_list.is_empty() {
                            msg.pop();
                            msg.pop();
                        }
                        msg.push_str("\n");
                    }
                    Ok(msg.clone())
                },
                Err(e) => {
                    // println!("{:?}", e);
                    Err(e)
                }
            }
        }
        "heads" => {
            let mut temp_hm: HashMap<String, RGData> = HashMap::new();
            // print!("{:?}", rg.heads);
            rg.heads.iter().for_each(|(k, v)| {temp_hm.insert(k.clone(), v.clone().unwrap().borrow_mut().data.clone());});
            print!("{:?}", rg.heads.keys());
            let msg = serde_json::to_string(&temp_hm);
            match msg {
                Ok(m) => Ok(m),
                Err(m) => Err("An error occurred in retrieving heads".to_string())
            } 
        }
        "diff" => {
            let mut msg = "".to_string();
            // Take 2 revisions 
            // Retrieve nodes associated with the two revs
            // Get the commit map from each node
            // Call diff on each pair of files from the commit map
            // If file exists in one commit map but not in other then
            println!("{:?}", rev_id);
            let comm_op_1 = rg.graph.get(&rev_id[0].unwrap());
            println!("{:?}", rg.graph.keys());
            let comm_op_2 = rg.graph.get(&rev_id[1].unwrap());
            let res = match (comm_op_1, comm_op_2){
                (Some(comm_node_1), Some(comm_node_2)) => {
                    let comm_map_1 =  comm_node_1.clone().unwrap().borrow_mut().data.commit_map.clone();
                    let comm_map_2 =  comm_node_2.clone().unwrap().borrow_mut().data.commit_map.clone();
                    comm_map_1.iter().for_each(|(k, v)| {
                        match comm_map_2.get(k){
                            Some(id) => {
                                let file_name = k.clone().into_os_string().into_string().unwrap();
                                let file_1_content = fl.retrieve_version(k, v.clone()).unwrap_or("".to_string());
                                let file_2_content = fl.retrieve_version(k, id.clone()).unwrap_or("".to_string());
                                let diff_res = algorithm_hiding::diff_file_versions(&file_1_content, &file_2_content);
                                msg = format!("{msg}\n{file_name}:\n{diff_res}");
                            } 
                            None => {

                                let file_name = k.clone().into_os_string().into_string().unwrap();
                                let diff_res = fl.retrieve_version(k, v.clone()).unwrap_or("".to_string());
                                msg = format!("{msg}\n{file_name}:\n{diff_res}");
                            }
                        }
                    });
                    Ok(msg)
                }
                _ => {Err("One or both of the revision IDs are invalid".to_string())}
            };
            res
            // Ok("Hopefully works??".to_string())
        }
        "merge" =>{
            let mut msg = "".to_string();
            let mut err = "".to_string();
            let mut merge_map: HashMap<PathBuf, String> = HashMap::new(); 
            let comm_op_1 = rg.graph.get(&rev_id[0].unwrap());
            let comm_op_2 = rg.graph.get(&rev_id[1].unwrap());
            match(comm_op_1, comm_op_2){
                (Some(comm_node_1), Some(comm_node_2)) => {
                    let comm_map_1 = comm_node_1.clone().unwrap().borrow_mut().data.commit_map.clone();
                    let comm_map_2 = comm_node_1.clone().unwrap().borrow_mut().data.commit_map.clone();
                    comm_map_1.iter().for_each(|(k,v)|{
                        match comm_map_2.get(k){
                            Some(id) => {
                                let file_1_content = fl.retrieve_version(k, v.clone()).unwrap_or("".to_string());
                                let file_2_content = fl.retrieve_version(k, id.clone()).unwrap_or("".to_string());
                                let merge_res = algorithm_hiding::merge_file_versions(&file_1_content, &file_2_content);
                                match merge_res{
                                    Ok(merge_content) => {merge_map.insert(k.clone(), merge_content.clone());}
                                    Err(e) => {err = e}
                                }
                            }
                            None => {
                                let file_1_content = fl.retrieve_version(k, v.clone()).unwrap_or("".to_string());
                                merge_map.insert(k.clone(), file_1_content.clone());
                            }
                        }
                    });
                    rg.add_merge_node(merge_map, rev_id[0].unwrap(), rev_id[0].unwrap());
                }
                _ => {err = "One or both of the revision IDs are invalid".to_string();}
            };
            let mut res = Ok(msg); 
            if err != "" {
                res = Err(err)
            }
            res
            // Ok("Hopefully works??".to_string())
        }
        "checkout" => {
            // rev_node.borrow_mut().data.track_list.clone()
            let rev_node = rg.graph.get(&rev_id[0].unwrap()).unwrap().as_ref().unwrap();
            let tl = rev_node.borrow_mut().data.track_list.clone();
            let cm = rev_node.borrow_mut().data.commit_map.clone();
            rg.checkout_commit(tl, cm);
            Ok("".to_string())
        }
        
        _ => {Err("Unsupported command".to_string())}
    };
    rg.serialize(rev_graph_info_file.clone());
    res
}


// Notes:
// Diff between two files returns trivial diff (basically returns one of the file's contents)
// File log save file does not work if the file is in an inner directory
// Main method should handle basic error handling (at least check whether the arguments given are in the right order
// would be very helpful to check if the files given exist by checking them against a list of all files in dir, list can be retrieved from file_management)
// Main needs to handle the heads command
// Main needs to handle the clone command (basically ask file_management to copy all the files from a dir)