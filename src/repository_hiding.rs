#![allow(unused)]
use crate::algorithm_hiding::{UniqueId, create_unique_id};
use crate::file_management::{Files, Directory};
use crate::file_system_hiding::file_log;
use file_log::FileLog;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use serde_json::json;
use serde_json::{Value, Error};
use std::rc::Rc;
use std::cell::{Ref, RefCell};
type NodePointer = Option<Rc<RefCell<RGNode>>>;

trait Serializable{
    fn serialize(&self, file_name: PathBuf) -> std::result::Result<(), Error>;
}
#[derive(Debug)]
struct RGData{
    // A list of file names tracked for given revision. Addition/removal of files from tracking list affects this
    track_list: Vec<PathBuf>,
    // Added a hashmap to track IDs associated with files of a given revision (ID generated by file_log module)
    commit_map: HashMap<PathBuf, UniqueId>,
}

impl RGData{
    fn new(file_names: Vec<PathBuf>) -> Self{
        RGData{
            track_list: file_names,
            commit_map: HashMap::new(),
        }
    }
    fn add_files(&mut self, file_names: Vec<PathBuf>){
        file_names.iter().for_each(|fname| self.track_list.push(fname.clone()));
    }
    fn remove_files(& mut self, file_names: Vec<PathBuf>){
        let temp_list: Vec<&PathBuf> = self.track_list.iter().filter(|&fname_1| !file_names.contains(fname_1)).collect();
        self.track_list = temp_list.iter().map(|&fname| fname.clone()).collect();
    }
}

// TODO: Think about whether data should be an Option or when data needs to be empty you should just have an empty vector?
#[derive(Debug)]
struct RGNode{
    data: RGData,
    p1: NodePointer,
    p2: NodePointer,
}

struct RevGraph<T> where T: Files{
    // Hashmap to keep track of revision and files associated with each
    graph: HashMap<UniqueId, NodePointer>,
    // Hashmap to keep track of nodes at the head of each branch
    heads: HashMap<String, NodePointer>,
    // Pointer to the current node of the current branch
    curr_rev: NodePointer,
    _t: Option<T>,
}

impl<T> RevGraph<T> where T: Files{
    fn init() -> Self{
        let rev = RevGraph{
            graph: HashMap::new(),
            heads: HashMap::new(),
            curr_rev: None,
            _t: None,
        };
        rev
    }
    // TODO: update to reinitialize rev graph from info stored in hidden dir
    fn reinit(data: &str) -> Self{
        RevGraph{
            graph: HashMap::new(),
            heads: HashMap::new(),
            curr_rev: None,
            _t: None,
        }
    }

    // TODO: This function should return result
    fn add_files(& mut self, file_names: Vec<PathBuf>, branch_name: String){
        match &self.curr_rev{
            Some(rg_node) => {
                // TODO: Handle the case of trying to add files that are already being tracked (error or just a message?)
                (*rg_node).borrow_mut().data.add_files(file_names);
            }
            _ => {
                let mut rg_node = Rc::new(RefCell::new(RGNode{
                    data: RGData::new(file_names),
                    p1: None,
                    p2: None,
                }));
                self.curr_rev = Some(rg_node);
                self.point_head(branch_name);
            }
        }
    }

    // TODO: This function should return result
    fn remove_files(& mut self, file_names: Vec<PathBuf>){
        match &self.curr_rev{
            Some(rg_node) =>{
                // TODO: Add the error case of when RGNode is initialized but no files are being tracked
                (*rg_node).borrow_mut().data.remove_files(file_names);
            }
            // TODO: Handle the Error case of trying to remove files when RGNode is either uninitialized
            _ => {

            }
        }
    }
    // TODO: This function should return result
    fn add_graph_node(& mut self, branch_name: String){
        match &self.curr_rev{
            // TODO: Handle the error case of committing when no files are being tracked
            Some(rg_node) =>{
                let mut fl = file_log::create_file_log::<Directory>();
                // Save snapshots of files being tracked
                // Add file_id (path) and uniqueID to the commit map for given revision
                (*rg_node).borrow_mut()
                            .data.track_list
                            .iter()
                            .for_each(|fname|
                                {let res = fl.save_file(fname.clone().as_path());
                                 match res{
                                    Ok(id) => {
                                        (*rg_node).borrow_mut().data.commit_map.insert(fname.clone(), id);
                                    }, 
                                    // TODO: handle error case properly
                                    Err(e) => (),
                                    }
                                });
                // Create a new node tracking same files as current revision
                // Set one of the parents to the current revision and stash away the curr rev
                // Set curr rev to the new node
                let new_node = Rc::new(RefCell::new(RGNode{
                    data: RGData::new(rg_node.borrow_mut().data.track_list.clone()),
                    p1: Some(Rc::clone(rg_node)),
                    p2: None,
                }));
                let id = create_unique_id();
                self.graph.insert(id, Some(Rc::clone(rg_node)));
                self.curr_rev = Some(new_node);
                self.point_head(branch_name);
            }
            _ => {
                // TODO: Handle the error case of committing before the node even exists
            }
        }
    }
    // adds a new head to the heads hashmap in rev_graph
    fn point_head(& mut self, branch_name: String) {
        match &self.curr_rev{
            Some(rg_node) =>{
                self.heads.insert(branch_name, Some(Rc::clone(rg_node)));
            }
            // TODO: Handle the Error case of trying to point head to curr_rev when curr_rev is uninitialized
            // Realistically, this case should not even arise
            _ => {

            }
        }
    } 
}

impl<T> Serializable for RevGraph<T> where T: Files{
    fn serialize(&self, file_name: PathBuf) -> std::result::Result<(), Error>{
        let rg_str = "{}".to_string();
        if self.graph.is_empty(){
            if let Err(e) = T::write_to_file(&file_name, &rg_str){
                eprintln!("Failed to create/write to file: {}", e);
            }
        }
        Ok(())
    }
}

pub fn action_handler<T: Files>(command: String, repo_name: String, file_names: Vec<PathBuf>, branch_name: String, rev_id: UniqueId) -> std::result::Result<String, String>{
    let file_name = PathBuf::from("rg_info.json");
    let mut init_res = String::from("initialized");
    let mut rg: RevGraph<T>;
    rg = RevGraph::init();

    // TODO: Combine init and reinit code (if rg_info has init info then reinit else init afresh)
    if command == "init"{
        // Serialize is called before exiting after completing command
        RevGraph::serialize(&rg, file_name);
        return Ok(init_res)
    }
    
    if command == "add"{
        // TODO: DECIDE IF THE CURR-REV SHOULD BE INITIALIZED WHEN THE GRAPH IS INITIALIZED OR WHEN ADD IS CALLED FOR THE FIRST TIME
        rg.add_files(file_names.clone(), branch_name.clone());
    }
    if command == "remove"{
        rg.remove_files(file_names.clone());
    }
    if command == "commit"{
        rg.add_graph_node(branch_name.clone());
    }
    if command == "status"{

    }
    if command == "cat"{
        let mut fl = file_log::create_file_log::<Directory>();
        let &file_id = rg.graph.get(&rev_id).unwrap().as_ref().unwrap().borrow_mut().data.commit_map.get(&file_names[0]).unwrap();
        if let Some(file_content) = fl.retrieve_version(file_names[0].as_path(), file_id) {
            return Ok(file_content);
        };
    }


    Err(String::from("failed"))
}